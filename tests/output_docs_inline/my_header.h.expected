// Automatically generated by Interoptopus.

#ifndef interoptopus_generated
#define interoptopus_generated

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>



const unsigned char MY_LIBRARY_U8 = 255;
const float MY_LIBRARY_F32_MIN_POSITIVE = 0.000000000000000000000000000000000000011754944;
const int MY_LIBRARY_COMPUTED_I32 = -2147483647;

/// Documented enum.
typedef enum my_library_enum_documented
{
    /// Variant A.
    MY_LIBRARY_ENUM_DOCUMENTED_A = 0,
    /// Variant B.
    MY_LIBRARY_ENUM_DOCUMENTED_B = 1,
    /// Variant B.
    MY_LIBRARY_ENUM_DOCUMENTED_C = 2,
} my_library_enum_documented;

typedef enum my_library_enum_renamed
{
    MY_LIBRARY_ENUM_RENAMED_X = 0,
} my_library_enum_renamed;

typedef struct my_library_generic2u8 my_library_generic2u8;

typedef struct my_library_generic3 my_library_generic3;

typedef struct my_library_generic4 my_library_generic4;

typedef struct my_library_opaque my_library_opaque;

/// Some struct we want to expose as a class.
typedef struct my_library_simple_service my_library_simple_service;

typedef struct my_library_simple_service_lifetime my_library_simple_service_lifetime;

typedef enum my_library_ffi_error
{
    MY_LIBRARY_FFI_ERROR_OK = 0,
    MY_LIBRARY_FFI_ERROR_NULL = 100,
    MY_LIBRARY_FFI_ERROR_PANIC = 200,
    MY_LIBRARY_FFI_ERROR_FAIL = 300,
} my_library_ffi_error;

#pragma pack(push, 2)
typedef struct my_library_aligned1
{
    unsigned char x;
    unsigned short y;
} my_library_aligned1;
#pragma pack(pop)

#pragma pack(push, 64)
typedef struct my_library_aligned2
{
    unsigned char x;
    unsigned short y;
} my_library_aligned2;
#pragma pack(pop)

typedef struct my_library_boolean_alignment
{
    int a;
    short b;
    short c;
    unsigned char d;
    unsigned char e;
    unsigned char f;
    unsigned char g;
    unsigned char h;
    unsigned char i;
    unsigned char j;
    unsigned char k;
    unsigned long id;
    bool is_valid;
    unsigned long datum;
} my_library_boolean_alignment;

typedef struct my_library_extra_typef32
{
    float x;
} my_library_extra_typef32;

typedef struct my_library_inner
{
    float x;
} my_library_inner;

#pragma pack(push, 1)
typedef struct my_library_packed1
{
    unsigned char x;
    unsigned short y;
} my_library_packed1;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct my_library_packed2
{
    unsigned char x;
    unsigned short y;
} my_library_packed2;
#pragma pack(pop)

typedef struct my_library_phantomu8
{
    unsigned int x;
} my_library_phantomu8;

typedef struct my_library_some_foreign_type
{
    unsigned int x;
} my_library_some_foreign_type;

/// Documented struct.
typedef struct my_library_struct_documented
{
    /// Documented field.
    float x;
} my_library_struct_documented;

typedef struct my_library_struct_renamed
{
    my_library_enum_renamed e;
} my_library_struct_renamed;

typedef struct my_library_tupled
{
    unsigned char x0;
} my_library_tupled;

typedef struct my_library_use_ascii_string_pattern
{
    const char* ascii_string;
} my_library_use_ascii_string_pattern;

typedef struct my_library_vec
{
    double x;
    double z;
} my_library_vec;

typedef struct my_library_vec1
{
    float x;
    float y;
} my_library_vec1;

typedef struct my_library_vec2
{
    double x;
    double z;
} my_library_vec2;

typedef struct my_library_vec3f32
{
    float x;
    float y;
    float z;
} my_library_vec3f32;

typedef struct my_library_visibility1
{
    unsigned char pblc;
    unsigned char prvt;
} my_library_visibility1;

typedef struct my_library_visibility2
{
    unsigned char pblc1;
    unsigned char pblc2;
} my_library_visibility2;

typedef struct my_library_weird1u32
{
    unsigned int x;
} my_library_weird1u32;

typedef unsigned char (*my_library_fptr_fn_u8_rval_u8)(unsigned char x0);

typedef unsigned char (*my_library_callback_u8)(unsigned char value);

typedef unsigned int (*my_library_my_callback)(unsigned int value);

typedef struct my_library_array
{
    unsigned char data[16];
} my_library_array;

typedef struct my_library_genericu32
{
    const unsigned int* x;
} my_library_genericu32;

typedef struct my_library_genericu8
{
    const unsigned char* x;
} my_library_genericu8;

typedef struct my_library_weird2u8
{
    unsigned char t;
    unsigned char a[5];
    const unsigned char* r;
} my_library_weird2u8;

///A pointer to an array of data someone else owns which may not be modified.
typedef struct my_library_slice_bool
{
    ///Pointer to start of immutable data.
    const unsigned char* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_bool;

///A pointer to an array of data someone else owns which may not be modified.
typedef struct my_library_sliceu32
{
    ///Pointer to start of immutable data.
    const unsigned int* data;
    ///Number of elements.
    unsigned long len;
} my_library_sliceu32;

///A pointer to an array of data someone else owns which may not be modified.
typedef struct my_library_sliceu8
{
    ///Pointer to start of immutable data.
    const unsigned char* data;
    ///Number of elements.
    unsigned long len;
} my_library_sliceu8;

///A pointer to an array of data someone else owns which may be modified.
typedef struct my_library_slice_mutu32
{
    ///Pointer to start of mutable data.
    const unsigned int* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_mutu32;

///A pointer to an array of data someone else owns which may be modified.
typedef struct my_library_slice_mutu8
{
    ///Pointer to start of mutable data.
    const unsigned char* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_mutu8;

///Option type containing boolean flag and maybe valid data.
typedef struct my_library_option_inner
{
    ///Element that is maybe valid.
    my_library_inner t;
    ///Byte where `1` means element `t` is valid.
    unsigned char is_some;
} my_library_option_inner;

///Option type containing boolean flag and maybe valid data.
typedef struct my_library_option_vec
{
    ///Element that is maybe valid.
    my_library_vec t;
    ///Byte where `1` means element `t` is valid.
    unsigned char is_some;
} my_library_option_vec;

typedef void (*my_library_my_callback_contextual)(const void* context, unsigned int value);

typedef void (*my_library_my_callback_void)(const void* ptr);

typedef struct my_library_delegate_callback_my_callback_contextual
{
    my_library_my_callback_contextual callback;
    const void* context;
} my_library_delegate_callback_my_callback_contextual;

///A pointer to an array of data someone else owns which may not be modified.
typedef struct my_library_slice_use_ascii_string_pattern
{
    ///Pointer to start of immutable data.
    const my_library_use_ascii_string_pattern* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_use_ascii_string_pattern;

///A pointer to an array of data someone else owns which may not be modified.
typedef struct my_library_slice_vec
{
    ///Pointer to start of immutable data.
    const my_library_vec* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_vec;

///A pointer to an array of data someone else owns which may not be modified.
typedef struct my_library_slice_vec3f32
{
    ///Pointer to start of immutable data.
    const my_library_vec3f32* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_vec3f32;

///A pointer to an array of data someone else owns which may be modified.
typedef struct my_library_slice_mut_vec
{
    ///Pointer to start of mutable data.
    const my_library_vec* data;
    ///Number of elements.
    unsigned long len;
} my_library_slice_mut_vec;

typedef unsigned char (*my_library_callback_ffi_slice)(my_library_sliceu8 slice);

typedef void (*my_library_callback_slice_mut)(my_library_slice_mutu8 slice);

typedef my_library_vec3f32 (*my_library_callback_huge_vec_slice)(my_library_slice_vec3f32 slice);


void primitive_void();

void primitive_void2();

bool primitive_bool(bool x);

unsigned char primitive_u8(unsigned char x);

unsigned short primitive_u16(unsigned short x);

unsigned int primitive_u32(unsigned int x);

unsigned long primitive_u64(unsigned long x);

char primitive_i8(char x);

short primitive_i16(short x);

int primitive_i32(int x);

long primitive_i64(long x);

my_library_boolean_alignment boolean_alignment(my_library_boolean_alignment x);

my_library_boolean_alignment boolean_alignment2(bool rval);

my_library_packed1 aligned_to_packed1(my_library_aligned1 a);

my_library_packed2 aligned_to_packed2(my_library_aligned2 a);

long many_args_5(long x0, long x1, long x2, long x3, long x4);

long many_args_10(long x0, long x1, long x2, long x3, long x4, long x5, long x6, long x7, long x8, long x9);

const long* ptr(const long* x);

/// # Safety
///
/// Parameter x must point to valid data.
long* ptr_mut(long* x);

const const long** ptr_ptr(const const long** x);

const long* ref_simple(const long* x);

long* ref_mut_simple(long* x);

bool ref_option(const long* x);

bool ref_mut_option(long* x);

my_library_tupled tupled(my_library_tupled x);

my_library_ffi_error complex_args_1(my_library_vec3f32 a, const my_library_tupled* b);

const my_library_opaque* complex_args_2(my_library_some_foreign_type cmplx);

unsigned char callback(my_library_fptr_fn_u8_rval_u8 callback, unsigned char value);

unsigned int generic_1a(my_library_genericu32 x, my_library_phantomu8 y);

unsigned char generic_1b(my_library_genericu8 x, my_library_phantomu8 y);

unsigned char generic_1c(const my_library_genericu8* x, const my_library_genericu8* y);

unsigned char generic_2(const my_library_generic2u8* x);

unsigned char generic_3(const my_library_generic3* x);

unsigned char generic_4(const my_library_generic4* x);

unsigned char array_1(my_library_array x);

/// This function has documentation.
my_library_enum_documented documented(my_library_struct_documented x);

my_library_vec1 ambiguous_1(my_library_vec1 x);

my_library_vec2 ambiguous_2(my_library_vec2 x);

bool ambiguous_3(my_library_vec1 x, my_library_vec2 y);

my_library_vec namespaced_type(my_library_vec x);

my_library_option_vec namespaced_inner_option(my_library_option_vec x);

my_library_slice_vec namespaced_inner_slice(my_library_slice_vec x);

my_library_slice_mut_vec namespaced_inner_slice_mut(my_library_slice_mut_vec x);

my_library_ffi_error panics();

my_library_enum_renamed renamed(my_library_struct_renamed x);

void sleep(unsigned long millis);

bool weird_1(my_library_weird1u32 x, my_library_weird2u8 y);

void visibility(my_library_visibility1 x, my_library_visibility2 y);

my_library_tupled repr_transparent(my_library_tupled x, const my_library_tupled* r);

unsigned int pattern_ascii_pointer_1(const char* x);

const char* pattern_ascii_pointer_2();

unsigned int pattern_ascii_pointer_len(const char* x, my_library_use_ascii_string_pattern y);

my_library_slice_use_ascii_string_pattern pattern_ascii_pointer_return_slice();

unsigned int pattern_ffi_slice_1(my_library_sliceu32 ffi_slice);

unsigned int pattern_ffi_slice_1b(my_library_slice_mutu32 ffi_slice);

my_library_vec3f32 pattern_ffi_slice_2(my_library_slice_vec3f32 ffi_slice, int i);

void pattern_ffi_slice_3(my_library_slice_mutu8 slice, my_library_callback_slice_mut callback);

void pattern_ffi_slice_4(my_library_sliceu8 slice, my_library_slice_mutu8 slice2);

void pattern_ffi_slice_5(const my_library_sliceu8* slice, my_library_slice_mutu8* slice2);

void pattern_ffi_slice_6(const my_library_slice_mutu8* slice, my_library_callback_u8 callback);

unsigned char pattern_ffi_slice_delegate(my_library_callback_ffi_slice callback);

my_library_vec3f32 pattern_ffi_slice_delegate_huge(my_library_callback_huge_vec_slice callback);

my_library_option_inner pattern_ffi_option_1(my_library_option_inner ffi_slice);

my_library_inner pattern_ffi_option_2(my_library_option_inner ffi_slice);

unsigned char pattern_ffi_bool(unsigned char ffi_bool);

char pattern_ffi_cchar(char ffi_cchar);

const char* pattern_ffi_cchar_const_pointer(const char* ffi_cchar);

char* pattern_ffi_cchar_mut_pointer(char* ffi_cchar);

unsigned long pattern_api_guard();

unsigned int pattern_callback_1(my_library_my_callback callback, unsigned int x);

my_library_my_callback_void pattern_callback_2(my_library_my_callback_void callback);

void pattern_callback_3(my_library_delegate_callback_my_callback_contextual callback, unsigned int x);

/// Destroys the given instance.
///
/// # Safety
///
/// The passed parameter MUST have been created with the corresponding init function;
/// passing any other value results in undefined behavior.
my_library_ffi_error simple_service_destroy(my_library_simple_service** context);

/// The constructor must return a `Result<Self, Error>`.
my_library_ffi_error simple_service_new_with(my_library_simple_service** context, unsigned int some_value);

my_library_ffi_error simple_service_new_without(my_library_simple_service** context);

my_library_ffi_error simple_service_new_with_string(my_library_simple_service** context, const char* ascii);

my_library_ffi_error simple_service_new_failing(my_library_simple_service** context, unsigned char some_value);

/// Methods returning a Result<(), _> are the default and do not
/// need annotations.
my_library_ffi_error simple_service_method_result(const my_library_simple_service* context, unsigned int anon1);

unsigned int simple_service_method_value(const my_library_simple_service* context, unsigned int x);

/// This method should be documented.
///
/// Multiple lines.
void simple_service_method_void(const my_library_simple_service* context);

unsigned char simple_service_method_mut_self(my_library_simple_service* context, my_library_sliceu8 slice);

/// Single line.
void simple_service_method_mut_self_void(my_library_simple_service* context, my_library_slice_bool slice);

unsigned char simple_service_method_mut_self_ref(my_library_simple_service* context, const unsigned char* x, unsigned char* y);

unsigned char simple_service_method_mut_self_ref_slice(my_library_simple_service* context, const unsigned char* x, unsigned char* y, my_library_sliceu8 slice);

unsigned char simple_service_method_mut_self_ref_slice_limited(my_library_simple_service* context, const unsigned char* x, unsigned char* y, my_library_sliceu8 slice, my_library_sliceu8 slice2);

my_library_ffi_error simple_service_method_mut_self_ffi_error(my_library_simple_service* context, my_library_slice_mutu8 slice);

my_library_ffi_error simple_service_method_mut_self_no_error(my_library_simple_service* context, my_library_slice_mutu8 slice);

/// Warning, you _must_ discard the returned slice object before calling into this service
/// again, as otherwise undefined behavior might happen.
my_library_sliceu32 simple_service_return_slice(my_library_simple_service* context);

/// Warning, you _must_ discard the returned slice object before calling into this service
/// again, as otherwise undefined behavior might happen.
my_library_slice_mutu32 simple_service_return_slice_mut(my_library_simple_service* context);

/// This function has no panic safeguards. If it panics your host app will be in an undefined state.
const char* simple_service_return_string(my_library_simple_service* context);

my_library_ffi_error simple_service_method_void_ffi_error(my_library_simple_service* context);

my_library_ffi_error simple_service_method_callback(my_library_simple_service* context, my_library_my_callback callback);

/// Destroys the given instance.
///
/// # Safety
///
/// The passed parameter MUST have been created with the corresponding init function;
/// passing any other value results in undefined behavior.
my_library_ffi_error simple_service_lt_destroy(my_library_simple_service_lifetime** context);

my_library_ffi_error simple_service_lt_new_with(my_library_simple_service_lifetime** context, const unsigned int* some_value);

void simple_service_lt_method_lt(my_library_simple_service_lifetime* context, my_library_slice_bool slice);

void simple_service_lt_method_lt2(my_library_simple_service_lifetime* context, my_library_slice_bool slice);

const char* simple_service_lt_return_string_accept_slice(my_library_simple_service_lifetime* anon0, my_library_sliceu8 anon1);

my_library_ffi_error simple_service_lt_method_void_ffi_error(my_library_simple_service_lifetime* context);


#ifdef __cplusplus
}
#endif

#endif /* interoptopus_generated */
